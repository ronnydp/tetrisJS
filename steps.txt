*------------------------*
|  TETRIS CON JAVASCRIPT |
*------------------------*

Inicializar el proyecto
~ npm create vite@latest (Vanilla JS)

Instalar dependencias 
~ pnpm install

Instalar dependencias √∫tiles para el proyecto
~ pnpm install standard -D (linter: para saber los errores inmediatamente)

Agregar en el package.json
~ "eslintConfig": {
    "extends": [
      "standard"
    ]
  }

Ingresar al proyecto (VsCode)
Eliminar archivos innecesarios para el proyecto
Empezar con el c√≥digo

1. Inicializar el canvas
"canvas" üóíÔ∏è
    Es un elemento del HTML que permite dibujar gr√°ficos en 2D o 3D directamente dentro de una p√°gina web usando JS. No tiene contenido por s√≠ mismo como <div> o <p>.

"context" üñåÔ∏è
    Es el objeto que permite dibujar dentro del canvas.
    ~ const context = canvas.getContext("2d" o "3d")

    M√©todos con context
    ~ .fillRect()           >>>     dibujar rect√°ngulos ‚èπÔ∏è
    ~ .beginPath(), .arc()  >>>     dibujar c√≠rculos üî¥
    ~ .moveTo(), .lineTo()  >>>     dibujar l√≠neas ‚ûñ
    ~ .drawImage()          >>>     dibujar im√°genes üñºÔ∏è
    ~ .fillText()           >>>     excribir texto üî°
    ~ .clearRect()          >>>     borrar ‚ùå

Definir las dimensiones del canvas (lienzo)
    canvas.width
    canvas.height

Escalar el sistema de coordenadas del canvas
    context.scale([coordenadas]) 

2. Game loop (clave para realizar todo tipo de juego)
    crear funcion update()  -> se llamar√° todo el tiempo
    crear funcion draw()    -> dibujar√° cada frame

    dentro de 'update()' llamar a draw()
    ~ window.requestAnimationFrame(update)
        quiere decir al navegador  "ejecuta esta funcion antes del proximo repintado de pantalla"
        funcion para crear animaciones suaves y eficientes en el navegador
        es m√°s eficiente que setInterval y setTimeout

dentro de 'draw()' dibujamos el rect√°ngulo y definimos el color del fondo
 ~ context.fillRect()
 ~ context.fillStyle()

3. Hacer el board
    Guiarse del BOARD_WIDTH, en este caso es 14, osea el board tendra 14 elementos o espacios horizontalmente, igual con el BOARD_HEIGHT que tiene 30, en resumen el BOARD(matriz) ser√° de 14x30. Rellenar de 0 y 1, los ceros ser√°n espacios vac√≠os y en los 1 ir√°n las piezas.

    Dentro del draw(), hacer un foreach para el board, poner otro foreach en cadena para cada fila(raw) del board, indicando que si es 1 se pinte de alg√∫n color. En una matriz siempre se itera en fila x columna [y][x].

4. Crear las piezas del jugador
    Establecer la posicion de la pieza {x:5, y:5} <- por ejemplo
    Definir la forma de la pieza mediante una matriz tambi√©n, por ejemplo para un cuadrado ser√≠a:
        [1, 1]
        [1, 1]
    Pintar la pieza en el board al igual que se hizo con el board y el foreach, pero cambiar el context.Retc(), a cada uno (x e y) se le sumar√° el piece.position.x, con esto la pieza nos queda como suspendida en el aire.

5. Darle movimiento a las piezas
    Con el evento keydown establecer el movimiento de las piezas.
    El evento de cada flecha lleva el nombre Arrow al inicio.

6. Colisiones
    Se crea una funci√≥n para revisar las colisiones(cuando una pieza choca con las demas o el limite del tablero). Revisar si hay un 1 o es undefined en la posici√≥n a donde se dirige la pieza.
    Para evitar que la pieza salga del tablero usar el operador de encadenamiento opcional'?.'
    Primero mover la pieza y luego verificar si hay colisi√≥n.

    [0,1] // piece.shape.find((row, y)) -> f1, f2, f3, etc 
    [1,1]    m√©todo find() -> 'recorre cada fila de la ficha y se detiene cuando hay igualdad'
            x  x  x  x  x
           c1 c2 c3 c4 c5
    f1 -> [ 0, 0, 0, 0, 0] <- y
    f2 -> [ 0, 0, 0, 0, 0] <- y
    f3 -> [ 0, 0, 0, 0, 0] <- y
    f4 -> [ 0, 0, 0, 0, 0] <- y
    f5 -> [ 0, 0, 0, 0, 0] <- y
    f6 -> [ 0, 0, 0, 0, 0] <- y

7. Solidificacion de las piezas luego de una colision
    Realizar la iteracion en las matrices nuevamente.
    Solo contamos los 1, osea los espacios no vac√≠os
    Cuando sea 1, se le asigna al board.
        board[y + piece.position.y][x + piece.position.x] = 1 // solidificamos
    
    Luego de detectar la colision llamar la funcion para solidificar, esto relacionado al evento "ArrowDown"
    Una vez solidificada la pieza reseteamos su position en x e y, esto dentro de la funcion que se usa para solidificar.

8. Eliminar las filas que se hayan completado.
    Buscar en el board una fila donde todos sean 1 // con foreach
    Guardar el indice de la fila en una array, se podrian econtrar mas de una fila llena
    Proceder con el borrado de las filas en el board.
    Agregar una nueva fila desde arriba del board.

9. Establecer la ca√≠da de la pieza cada por cada segundo.
    Necesito una funci√≥n que se repita cada frame
    Necesito medir cu√°nto tiempo pas√≥ entre frames
    Necesito acumular ese tiempo
    Y realizar acci√≥n cuando el acumulador llega al l√≠mite

    Regla General:
        Si algo en el juego se mueve con el paso del tiempo, se requiere:
            - Medir el tiempo entre cada frame -> dropCounter
            - Acumularlo
            - Realizar acci√≥n cuando se cumpla cierta condici√≥n.

    Una vez definida la ca√≠da de la pieza por tiempo, revisar revisar colisiones, solidificar y eliminar filas llenas.

10. Realizar dem√°s piezas del tetris (array de arrays)
    Hacer que aparezcan en modo random
    Ocurre cuando se resetea la posicion de la pieza una vez solidificada

11. Game over
12. Rotar la pieza
    shape           -> matriz completa
    shape.length    -> cuantas filas tiene la matriz
    shape[0]        -> primera fila (un array)
    shape[0].length -> cuantas columnas tiene la fila

13. Agregar puntuaciones
    Cada vez que se elimina una fila
